import { MenuBarExtra, getPreferenceValues, open, showToast, Toast } from "@raycast/api";
import { useState, useEffect } from "react";
import axios from "axios";
import Throttler from "./utils/throttler";
import { Alert, AlertType, ContentType, ContentTypeURLMap } from "./types/alert";
import { formatRelativeDate } from "./utils/dateUtils";

const apiKey = getPreferenceValues<{ apiKey: string }>().apiKey;
const throttler = new Throttler();

let alertCache: Alert[] = [];

function useCachedAlerts(): [Alert[], React.Dispatch<React.SetStateAction<Alert[]>>, boolean] {
  const [alerts, setAlerts] = useState<Alert[]>(alertCache);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  useEffect(() => {
    const fetchAlerts = async () => {
      if (throttler.isRateLimited(false)) {
        console.warn("Rate limit exceeded. Skipping fetch.");
        return;
      }
      setIsLoading(true);
      try {
        await throttler.stallIfRequired(false);
        const { data } = await axios.get<{ result: string; data: Alert[] }>("https://api.builtbybit.com/v1/alerts", {
          headers: { Authorization: `Private ${apiKey}` },
        });

        if (data.result === "success" && data.data) {
          console.log("Fetched alerts successfully.");
          alertCache = data.data;
          setAlerts(data.data);
        }
      } catch (error) {
        if (axios.isAxiosError(error) && error.response?.status === 429) {
          const retryAfter = parseInt(error.response.headers["retry-after"] || "10", 10) * 1000;
          throttler.setRead(retryAfter);
          console.error(`Rate limit exceeded. Retrying after ${retryAfter} ms.`);
        }
        console.error("Failed to fetch alerts", error);
        showToast(Toast.Style.Failure, "Failed to fetch alerts");
      } finally {
        setIsLoading(false);
      }
    };

    fetchAlerts();
    const intervalId = setInterval(fetchAlerts, 5 * 60 * 1000);

    return () => clearInterval(intervalId);
  }, []);

  return [alerts, setAlerts, isLoading];
}

const pendingUsernames: Set<number> = new Set();

async function fetchUsername(
  memberId: number,
  setUsernames: React.Dispatch<React.SetStateAction<Map<number, string>>>,
) {
  if (pendingUsernames.has(memberId)) {
    console.log(`Username fetch already pending for member ID ${memberId}`);
    return; // If the username is already being fetched, return early
  }

  if (throttler.isRateLimited(false)) {
    console.warn("Currently rate-limited, skipping fetch.");
    return; // If rate-limited, return early
  }

  pendingUsernames.add(memberId);

  try {
    await throttler.stallIfRequired(false);

    const { data } = await axios.get<{ result: string; data: { username: string } }>(
      `https://api.builtbybit.com/v1/members/${memberId}`,
      {
        headers: { Authorization: `Private ${apiKey}`, "Content-Type": "application/json" },
      },
    );

    if (data.result === "success") {
      console.log(`Fetched username for member ID ${memberId}: ${data.data.username}`);
      setUsernames((prev) => {
        const newMap = new Map(prev);
        newMap.set(memberId, data.data.username);
        return newMap;
      });
    }
  } catch (error) {
    if (axios.isAxiosError(error) && error.response?.status === 429) {
      const retryAfter = parseInt(error.response.headers["retry-after"] || "10", 10) * 1000;
      throttler.setRead(retryAfter);
      console.error(`Rate limit exceeded for member ID ${memberId}. Retrying after ${retryAfter} ms.`);
    } else {
      console.error(`Error fetching username for member ID ${memberId}:`, error);
      showToast(Toast.Style.Failure, `Error fetching username for ${memberId}`);
    }
  } finally {
    pendingUsernames.delete(memberId);
  }
}

export default function Command() {
  const [alerts, setAlerts, isLoading] = useCachedAlerts();
  const [isMarking, setIsMarking] = useState(false);
  const [usernames, setUsernames] = useState<Map<number, string>>(new Map());

  useEffect(() => {
    alerts.forEach((alert) => {
      if (!usernames.has(alert.caused_member_id)) {
        console.log(`Fetching username for member ID ${alert.caused_member_id}`);
        fetchUsername(alert.caused_member_id, setUsernames);
      } else {
        console.log(
          `Using cached username for member ID ${alert.caused_member_id}: ${usernames.get(alert.caused_member_id)}`,
        );
      }
    });
  }, [alerts]);

  const markAllAsRead = async () => {
    if (throttler.isRateLimited(true)) {
      console.warn("Currently rate-limited, skipping mark all as read.");
      return;
    }
    setIsMarking(true);
    showToast(Toast.Style.Success, "Marking all alerts as read...");
    try {
      await throttler.stallIfRequired(true);

      const response = await axios.patch(
        "https://api.builtbybit.com/v1/alerts",
        { read: true },
        {
          headers: { Authorization: `Private ${apiKey}`, "Content-Type": "application/json" },
        },
      );

      if (response.status !== 200) throw new Error(`Failed to mark all alerts as read: ${response.statusText}`);

      console.log("Marked all alerts as read.");
      showToast(Toast.Style.Success, "âœ… All Alerts Marked as Read");
      alertCache = [];
      setAlerts([]);
    } catch (error) {
      if (axios.isAxiosError(error) && error.response?.status === 429) {
        const retryAfter = parseInt(error.response.headers["retry-after"] || "10", 10) * 1000;
        throttler.setRead(retryAfter);
        console.error(`Rate limit exceeded. Retrying after ${retryAfter} ms.`);
      } else {
        console.error("Error marking alerts as read:", error);
        showToast(Toast.Style.Failure, "Failed to mark alerts as read");
      }
    } finally {
      setIsMarking(false);
    }
  };

  return (
    <MenuBarExtra
      icon={{ source: "bbb-icon.png" }}
      title={isLoading || isMarking ? "Loading alerts..." : `${alerts.length || 0} Notifications`}
      isLoading={isLoading || isMarking}
    >
      <MenuBarExtra.Section>
        <MenuBarExtra.Item
          title="View All Alerts"
          shortcut={{ modifiers: ["cmd", "shift"], key: "o" }}
          onAction={() => open("https://builtbybit.com/account/alerts")}
        />
      </MenuBarExtra.Section>
      <MenuBarExtra.Section>
        <MenuBarExtra.Item title={alerts.length !== 0 ? "Unread Notifications" : "No Unread Notifications"} />
        {alerts.map((alert) => {
          const username = usernames.get(alert.caused_member_id) || "Unknown";
          console.log(`Rendering alert for ${alert.caused_member_id}: ${username}`); // Debugging line
          const subtitle = formatRelativeDate(alert.alert_date);
          let title = `${username}: ${alert.alert_type}`;
          let url = "https://builtbybit.com/account/alerts";

          if (alert.alert_type === AlertType.REPLY) {
            if (alert.content_type === ContentType.THREAD) {
              title = `${username} replied to a thread`;
            } else if (alert.content_type === ContentType.TICKET) {
              title = `${username} replied to a ticket`;
            } else if (alert.content_type === ContentType.CONVERSATION) {
              title = `${username} replied to a conversation`;
            }
          } else if (alert.alert_type === AlertType.REACTION) {
            title = `${username} reacted to your message`;
          }

          if (alert.content_type in ContentTypeURLMap) {
            url = `${ContentTypeURLMap[alert.content_type as ContentType]}/${alert.content_id}`;
          }

          return (
            <MenuBarExtra.Item
              key={alert.content_id}
              title={title}
              subtitle={subtitle}
              onAction={() => {
                open(url);
              }}
            />
          );
        })}
      </MenuBarExtra.Section>

      <MenuBarExtra.Section>
        <MenuBarExtra.Item
          title="Mark All as Read"
          shortcut={{ modifiers: ["cmd"], key: "enter" }}
          onAction={markAllAsRead}
        />
        <MenuBarExtra.Item
          title="Refresh Alerts"
          onAction={() => setAlerts(alertCache)}
          shortcut={{ modifiers: ["cmd"], key: "r" }}
        />
      </MenuBarExtra.Section>
    </MenuBarExtra>
  );
}
